{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE TypeFamilies #-}

module Data.Validation.Aeson where

import GHC.Exts (IsList(..))
import Control.Applicative
import Control.Monad
import Control.Monad.Reader
import Control.Monad.Except (catchError, throwError)
import Data.Proxy
import qualified Data.Map as M
import qualified Data.List as L
import qualified Data.Text as T
import Data.String
import Data.Aeson as J
import qualified Data.Aeson.BetterErrors as JB
import qualified Data.Aeson.BetterErrors.Internal as JBI
import qualified Data.DList as DL
import Data.Aeson.Types
import Data.Validation.Validation

-- ----------------------------------------------------------------
-- For JSON 
-- ----------------------------------------------------------------

-- | Declares a method to get JSON parser by the type of a field.
--
-- Besides following instances, instance definition of every @Validatable@ type is generated by @validatable@.
class AsType a where
    -- | Returns JSON parser by a type.
    asType :: Proxy a -- ^ Type specifier.
           -> JB.Parse ValidationError' a -- ^ JSON parser.

instance AsType [Char] where
    asType _ = JB.asString
instance {-# OVERLAPPABLE #-} (Integral a) => AsType a where
    asType _ = JB.asIntegral
instance AsType Float where
    asType _ = JB.asRealFloat
instance AsType Double where
    asType _ = JB.asRealFloat
instance AsType Bool where
    asType _ = JB.asBool
instance {-# OVERLAPPABLE #-} (AsType a) => AsType [a] where
    asType _ = JB.eachInArray $ asType (Proxy :: Proxy a)
instance AsType Object where
    asType _ = JB.asObject

-- | Declares a method to get JSON parser by the type and the pointer to value in current parsing state.
--
-- This method is used to generate the instance of @FromJSONBetterErrors@
-- In the generated code, @Pointer@ given as second argument is always @KeyPointer@.
-- Although, it can be @RawPointer@ when invoked from other instance implementation.
class AsField a where
    -- | Returns JSON parser for a field.
    asField :: Proxy a -- ^ Type specifier for the field.
            -> Pointer -- ^ Pointer indicating target value to parse in current state.
            -> JB.Parse ValidationError' a -- ^ JSON parser.

instance {-# OVERLAPPABLE #-} (AsType a) => AsField a where
    asField p (KeyPointer n) = JB.key (T.pack n) (asType p)
    asField p _ = asType p
-- Without this instance, 'AsField [a]' has higher priority than '(AsType a) => AsField a'.
instance {-# OVERLAPPING #-} AsField [Char] where
    asField p (KeyPointer n) = JB.key (T.pack n) (asType p)
    asField p _ = asType p
instance (AsField a) => AsField (Maybe a) where
    asField _ (KeyPointer n) = JB.keyOrDefault (T.pack n)
                                               Nothing
                                               (JB.perhaps $ asField (Proxy :: Proxy a) RawPointer)

instance {-# OVERLAPS #-} (AsField a, AllVerifiable vs a) => AsField (a :? vs) where
    asField _ n = do
        source <- JB.asValue >>= return . toSource
        asField (Proxy :: Proxy a) n >>= \v -> do
                case verifyAll (Proxy :: Proxy vs) v of
                    Left e -> JB.throwCustomError e
                    Right v' -> return $ SafeData v' (Proxy :: Proxy vs)

instance {-# OVERLAPS #-} (AsField a) => AsField [a] where
    asField _ (KeyPointer n) = JB.key (T.pack n) $ JB.eachInArray $ eachItem
        where
            eachItem = do
                JBI.ArrayIndex i <- (last . DL.toList . JBI.rdrPath) <$> ask
                asField (Proxy :: Proxy a) (IndexPointer i)

instance (IsString k, AsField v, Ord k) => AsField (M.Map k v) where
    asField _ (KeyPointer n) = JB.key (T.pack n) $ do
        obj <- JB.asObject
        fromList <$> mapM conv (toList obj)
        where
            conv :: (T.Text, Value) -> JB.Parse ValidationError' (k, v)
            conv (key, val) = do
                v <- local (JBI.setValue val . JBI.appendPath (JBI.ObjectKey key)) $ asField (Proxy :: Proxy v) RawPointer
                return (fromString $ T.unpack key, v)
instance {-# OVERLAPPABLE #-} (AsField a) => AsField (F a) where
    asField _ n = do
        source <- JB.asValue >>= return . toSource
        (asField (Proxy :: Proxy a) n >>= \v' -> return (F (Just v') source Nothing))
            `catchError` \e -> return $ case e of
                JB.InvalidJSON s -> F Nothing (StringValidatable s) (Just $ ErrorString "invalid JSON format")
                JB.BadSchema _ es -> case es of
                    JB.CustomError ve -> F Nothing source (Just $ ve)
                    JB.KeyMissing _ -> F Nothing source (Just $ ValueMissing)
                    JB.WrongType _ v -> F Nothing source (Just $ TypeMismatch (Proxy :: Proxy a))
                    JB.FromAeson s -> F Nothing source (Just $ ErrorString s)
                    JB.OutOfBounds _ -> F Nothing source (Just $ TypeMismatch (Proxy :: Proxy a))
                    JB.ExpectedIntegral _ -> F Nothing source (Just $ TypeMismatch (Proxy :: Proxy a))
