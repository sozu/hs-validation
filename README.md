# hs-validation

> All APIs are under development and they can be changed or removed without any notice.

This repository contains Haskell validation library providing following functionalities.

1. Type based declaration of validation method designed to be applied to each record in data types.
2. Creating an object from an Aeson instance when defined validations pass.
    - HTTP form is also supported with restrictions.
3. When validations fail, providing errors which contains not only messages but more meaningful informations.

## Usage

### Definition of data validation

An example below shows how you can set the validation method to each record.

```
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE TypeOperators #-}

import Data.Validation

data Foo = Foo { foo :: String :? '[Longer String 5]
               , bar :: Integer :? '[GT Integer 5]
               , baz :: Double :? '[$(lt 3.5) Double]
               }

$(validatable [''Foo])
-- validatable generates
-- data Foo' = Foo' { foo' :: F (String :? '[Longer String 5])
--                  , bar' :: F (Integer :? '[GT Integer 5])
--                  , baz' :: F (Double :? '[$(lt 3.5) Double])
--                  }
```

`Foo` is a data type having 3 records each type of which is set the validation method by `:?` operator. This declaration claims

- `foo` must be a `String` whose length is longer than `5`.
- `bar` must be an `Integer` which is greater than `5`.
- `baz` must be a `Double` which is less than `3.5`.

And then, `validatable` generates another type `Foo'` which also has 3 records corresponding to `Foo`'s as shown by comments.

You can find predefined validation methods like `Longer` and `GT` under `Data.Validation.Verifiers` package, or declare `Verifier` instance types to introduce your own validation methods as described below.

> TODO: Detail type wrapping logic in case of list, map and Maybe.

### Creating an object

You can create `Foo`'s object from an object of Aeson instance. The value of each record is obtained by the field of the same name.

```
import Data.Aeson as J
import Data.Validation

main = do
    let (Success v') = fromJSON $ object [ ("foo", J.String "abcdef")
                                         , ("bar", J.Number 6)
                                         , ("baz", J.Number 3.2)
                                         ] :: Result Foo'
    case validate v' of
        Just v -> do
            -- v :: Foo
            let r = (foo .! v, bar .! v, baz .! v) :: (String, Integer, Double)
            print r
        Nothing -> do
            -- errorsOf v' :: [ValidationError]
            ...
```

`fromJSON` always returns `Success` when applied to types generated by `validatable` and all errors are stored in `F` which is the wrapper type of each record. Therefore, you can know whether the validation succeeded by checking whether `validate` on `Foo'` object returns `Just` or `Nothing`. When validation succeeded, that is, when the argument of `fromJSON` was converted into `Foo` successfully, `Just` matches and `Foo`'s object becomes available. Otherwise, applying `errorsOf` to `F'` returns `ValidationError`s each of which contains detailed error for a record respectively.

Above example also shows the way to convert record value from declared type which probably is qualified with `Verifier`s with `:?` operator into the type on its LHS you originally expect. `.!` operator takes the selector and returns a value of expected type regardless whether the type is qualified or not. Note that returned type must be inferable because the operator is defined under a type class `SafeAccess`.

### Error handling

As shown in the example code, `errorsOf` returns the list of `ValidationError`s which happened in the validation suite. Each `ValidationError` is associated with a record, thus you can understand where the error happened in the form of `PointerPath` contained in the error. Besides, `ValidationError` is designed as it can provide complete information for when (in what phase) it happened and what it is. As opposed to many validation libraries providing error messages only, these features are important to implement real application which often needs complicated control flow according to the kind of error cause.

> TODO: Write error handling example and its explanation

`ValidationError` is an instance of `Show`, thus you can get default error message simply by using `show`. To customize error message, you have to prepare the mapping from error key to message format. Error key is determined according to the type of the error as follows.

| key | error type |
|----|----|
| missing   | Corresponding field did not exist (except for `Maybe` record). |
| mismatch  | The type of corresponding field did not match. |
| (various) | `Verifier` failed by some reason. The key is defined for each reason in each `Verifier`. |

> TODO: List predetermined key of Verifiers

Error format is a string which is formattable by `Text.Printf` package. This library extends the format slightly as it can order the arguments. Like printf in C, `n$` prefix in specifier takes the n-th argument. For example, formatting `"Second: %1$s, First: %0$s"` with arguments `"abc", "def"` results in `"Second: def, First: abc"`. 

> TODO: Write message formatting example

`formatError` is the function generating error message in custom format. Its first argument is the mapping from error key to messsage format. Second one is the function which formats `PointerPath` of the error into meaningful text. Finally, the error is formatted with mapped message format and the list of arguments, the beginning of which is the formatted `PointerPath` and values given by `Verifier` follow.